#include "Aligment.hpp"
#include "Initialization.hpp"
#include "Diamond_Inheritance.hpp"
#include "Overload_Resolution.hpp"
#include "Virtual.hpp"

#include <iostream>
#include <vector>

/*
 Сайты: https://learn.microsoft.com/ru-ru/cpp/cpp/initializers?view=msvc-170
        https://habr.com/ru/companies/jugru/articles/469465/
        https://ru.stackoverflow.com/questions/616184/%D0%9A%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-alignas
 */


int main()
{
    // virtual
    {
        Virtual::start();
    }
    // Разрешение перегрузки
    {
        overload_resolution::start();
    }
    /*
     Инициализация - язык от C унаследованы 5 типов инициализации: 1) инициализация по умолчанию, 2) нулевая инициализация, 3) копирующая инициализация, 4) агрегатная и 5) статическая инициализация.
     язык С++: прямая инициализация (С++98), инициализация значением (С++03), универсальная инициализация (инициализация списком) (C++11), назначенная инициализация (С++20), прямая инициализация агрегатных типов (ЕЩЕ НЕ СДЕЛАЛИ в C++23).
     */
    {
        /*
         1) Инициализация по умолчанию — это инициализация с помощью конструктора по умолчанию. Если класс, структура или объединение не имеет конструктор по умолчанию, компилятор выдает ошибку.
         */
        {
            [[maybe_unused]] int i;
        }
        /*
         2) Нулевая инициализация - это инициализируются с помощью (ПУСТЫХ) фигурных скобок.
         */
        {
            [[maybe_unused]] int i{};
        }
        /*
         3) Инициализация копированием — это инициализация одного объекта с использованием другого объекта. Инициализация копированием не может вызывать явные (explicit) конструкторы.
         */
        {
            struct Widget
            {
                explicit Widget(int) {}
            };

            // Widget w = 1; // ошибка: explicit
            [[maybe_unused]] int i = 0;
        }
        /*
         4) Агрегатная инициализация - это инициализация с использованием (НЕпустых) фигурных скобок без использования конструктора при отсутствии НЕзакрытых членов класса/структуры в последовательном порядке, где можно при желании пропустить инициализацию последних членов класса/структуры для них используется нулевая инициализация. Агрегатная инициализация использует копирующую инициализацию для каждого элемента. В отличие от копируемой инициализации она НЕ может вызывать явные (explicit) конструкторы.
         */
        {
            [[maybe_unused]] int i[4] = {0, 1, 2, 3};
            struct Widget
            {
                Widget(int i, int j) : i(i), j(j) {}
                int i;
                int j;
            };
            
            struct Thingy
            {
                Widget w;
                int k;
            };
            
            [[maybe_unused]] Thingy t1 = { Widget(1, 2), 3 };
            [[maybe_unused]] Thingy t2 = { Widget(1, 2) };
            [[maybe_unused]] Thingy t3 { t1 };
        }
        /*
         5) Статическая инициализация - статические переменные ВСЕГДА инициализируются!
         */
        {
            [[maybe_unused]] static int i1 = 0; // инициализация 0
            [[maybe_unused]] static int i2;     // инициализация 0
        }
        /*
         6) Прямая инициализация (С++98) — это инициализация с использованием (НЕпустых) круглых/фигурных скобок и выполняется ТОЛЬКО для конструкторов при помощи разрешения перегрузки. В отличие от копируемой инициализации она может вызывать явные (explicit) конструкторы.
         */
        {
            struct Widget
            {
                explicit Widget(int ii): i(ii) {}
                int i;
            };

            // Widget w1 = 1; // ошибка: explicit
            Widget w2(1);  // можно
            Widget w3{1};  // можно
        }
        /*
         7) Инициализация со значением (С++03) — это инициализация с использованием (пустых) круглых при наличии ОПРЕДЕЛЕННЫМ ПОЛЬЗОВАТЕЛЕМ конструктором по умолчанию, инициализация значением вызывает этот конструктор, в противном случае возвращается нуль.
         */
        {
            [[maybe_unused]] int i = int(); // C++98: UB, C++03: 0
            struct Widget1
            {
                int i; // i == 0
            };
                
            struct Widget2
            {
                Widget2() {}
                int i; // i == UB
            };
                
            struct Widget3
            {
                Widget3() = default; // конструктор определен пользователем, но не предоставлен пользователоем (user-defined, но не user-provided)
                int i; // i == 0
            };
            
            auto widget1 = Widget1();
            auto widget2 = Widget2();
            auto widget3 = Widget3();
            widget1.i; // i == 0
            widget2.i; // i == UB
            widget3.i; // i == UB
        }
        /*
         8) Универсальная инициализация (инициализация списком) (C++11) - это инициализация с использованием braced-init-list - std::initializer_list, бывает двух типов: прямая и копирования.
         */
        {
            std::vector<int> vec1 {0, 1, 2, 3, 4}; // direct-list-initialization
            std::vector<int> vec2 = {0, 1, 2, 3, 4}; // copy-list-initialization
            
            // Могут быть проблемы с ПРЯМОЙ инициализацией
            {
                std::vector<int> v3(3, 0); // вектор содержит 0, 0, 0
                std::vector<int> v4{3, 0}; // вектор содержит 3, 0
            }
            // Могут быть проблемы с конструктором по умолчанию
            {
                struct Widget1
                {
                    Widget1(){} // конструктор по умолчанию
                    Widget1(const std::initializer_list<int>& list) {}
                    
                    int i;
                };
                
                struct Widget2
                {
                    Widget2() = default;
                    int i;
                };
                
                Widget1 widget1{}; // вызовется конструктор по умолчанию
                widget1.i; // i == UB
                Widget2 widget2{}; // вызовется конструктор по умолчанию
                widget2.i; // i == 0
            }
        }
        /*
         9) Назначенная инициализация (С++20) - это агрегатная инициализация с другим синтаксисом - можно не соблюдать порядок элементов.
         */
        {
            struct Widget
            {
               int a;
               int b;
               int c;
            };
            
            struct Thingy
            {
               Widget w;
               int d;
            };
            
            [[maybe_unused]] Widget widget {.a = 1, .c = 3};
            [[maybe_unused]] Thingy thingy = {.w{.a = 1, .b = 2, .c = 3}, .d = 4};
        }
        /*
         10) Прямая инициализация агрегатных типов (ЕЩЕ НЕ СДЕЛАЛИ в C++23) - это прямая инициализация + агрегатная инициализация, с использованием (НЕпустых) КРУГЛЫХ скобок без использования конструктора при отсутствии НЕзакрытых членов класса/структуры в последовательном порядке.
         */
        {
            struct Widget
            {
                int i;
                int j;
            };
            
            // Widget widget(1, 2); (ЕЩЕ НЕ СДЕЛАЛИ в C++23)
        }
    }
    // Порядок инициализации членов класса зависит от порядка их объявления, а не от порядка их в конструкторе!!!
    {
        initialization_order::start();
    }
    std::cout << std::endl;
    // Обычное наследование
    {
        inheritance::start();
    }
    std::cout << std::endl;
    // Ромбовидное наследование
    {
        diamond_inheritance::start();
    }
    /*
     Выравнивание памяти (aligment) - необходимо для эффективного обращения процессора к данным в памяти. 
     Процессору проще обращаться к данным, когда они последовательно лежат по блокам в 4 байта для 32-битной ОС /8 байт 64-битной ОС, поэтому компилятор подкладывает (padding) неиспользуемые байты для выравнивания к границам блоков памяти по 4/8 байт.
     */
    {
        aligment::start();
    }
}
